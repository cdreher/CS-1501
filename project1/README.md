# CS 1501 Project 1

Goal:
To demonstrate knowledge of both exhaustive search of a problem space and lookup search through the implementation of a very basic brute-force password cracker.

Background:
Let's assume that you are writing a password cracker that targets the following policy:

Passwords have to be exactly 5 characters long (no shorter, no longer)
1–3 of which must be letters (lowercase a–z, no capitals)
1–2 of which must be numbers
1–2 of which must be symbols (specifically !, @, $, ^, _, or *)
Passwords must not contain any of the 500 most used English words (found in dictionary.txt), or any of these words with one or more numbers/symbols substituted for letters (specifically, 7 for t, 4 for a, 0 for o, 3 for e, 1 for i, 1 for l, or $ for s)
Your program will have two parts:

It will enumerate all valid passwords (i.e., all those that abide by the above policy), timing how long it takes to get to each one.

It will allow the user to enter passwords and report how long your cracker took to guess that password. If the entered password is not valid, your program will select 10 alternative valid passwords and report their times.

Specifications:
You must implement a De La Briandais (DLB) trie data structure (as described in lecture) to use in your project.
Your main program must be called from the command line with one of two command line arguments, either -find or -check (that is, it should be run as either java PwCheck -find or java PwCheck -check). Your program should first be run with the -find argument before being run with the -check argument.
When called with the -find argument, your program should generate the list of all passwords and record the time required to reach each one (in milliseconds). To do so, complete the following steps.
You are provided a list of dictionary words to check in dictionary.txt. Use this file to populate a DLB trie with strings that cannot be contained within user passwords.
Use exhaustive search and pruning rules to find all valid passwords. Be sure to carefully choose your pruning rules! Your search needs to be as efficient as you can make it.
Time the running of your program to see how long it takes your program to generate each possible valid password.
You must write the list of valid passwords and the time required to find each one out to a text file called all_passwords.txt.
Each line of this file should contain the password and then the time in ms separated by a comma (e.g., q!23z,2.34567)
When called with the -check argument, your program should prompt the user to enter passwords until they wish to stop. You should check that a list of all valid passwords has already been generated (i.e., your program has already been run with the -find option and all_passwords.txt exists). Then, do the following:
For each entered password, there are two options: it is either a valid password, or it is not.
If it is a valid password, inform the user how long it took your cracker to guess that password.
If it is not a valid password, find 10 valid passwords that share the longest prefix with the entered password and inform the user how long it took your cracker to guess each of these alternative passwords.
To facilitate these checks, you should create a symbol table that stores the key/value (password/time) pairs from all_passwords.txt in such a way that it makes it most efficient for the user to continually enter passwords and get timing reports back.
Create a new file called ST_approach.txt that (a) describes your approach to implementing this symbol table, and (b) justifies your decision to take this approach. Note that this file does not need to be extensive, just a few lines so the TA is aware of what to look for in your code and why you chose this approach.
Submission Guidelines:
DO NOT upload all_passwords.txt to your Box folder. This must be generated by calling your program with the -find command line option.
DO NOT SUBMIT any IDE package files.
You must name your main program file PwCheck.java.
You must be able to compile your program by running javac PwCheck.java.
You must be able to run your program by running java PwCheck [ -find | -check ].
You must fill out info_sheet.txt.
The project is due at 11:59 PM on Friday, February 10. Upload your progress to Box frequently, even far in advance of this deadline. No late assignments will be accepted. At the deadline, your Box folder will automatically be changed to read-only, and no more changes will be accepted. Whatever is present in your Box folder at that time will be considered your submission for this assignment—no other submissions will be considered.
Additional Notes:
Since passwords should only contain lower case letters, your program should run in a case insensitive manner. Any capitalized letters in the dictionary or user input should be converted to lower case letters.
Generating all valid passwords may take some time. Be sure to give yourself plenty of time to debug your program with this in mind.
The list of all valid passwords/times will be rather large, be sure to account for this in devising a solution to implement your symbol table.
To increase the efficiency of your search for valid passwords, be sure not to perform unnecessary dictionary checks.
Also keep in mind that valid passwords cannot contain dictionary words anywhere, e.g., !and5 is a bad password because it contains the word and.
You only need to consider the number/symbol letter replacements listed above when looking for dictionary words: 7 for t, 4 for a, 0 for o, 3 for e, 1 for i, 1 for l, or $ for s. You do not need to consider any other substitutions.
Your DLB implementation must be all your own code. You cannot build the trie around Java Class Library (JCL) data structures such as the ArrayList or LinkedList classes.
You may use Java's System.nanoTime() to calculate the runtime of your program.
